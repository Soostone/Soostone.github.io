{"0": {
    "doc": "About",
    "title": "About",
    "content": "# Napkin ## Intro Napkin Wiki is a collection of HOWTOs and tutorials about the tool assisting data scientists when they crunch data through their relational and NoSQL DBs. [napkinweb](https://napkinweb.webflow.io/){:target=\"_blank\" rel=\"noopener\"} ## About Napkin app What is napkin? It is a few things bundled together: 1. A SQL wrapper in Haskell geared towards Redshift and therefore Postgres. * The general idea is to be able to express any hand-written SQL, no matter how complex, directly in Haskell via types and a structure that mirror SQL directly. * The Untyped folder coupled with Napkin.Types has all the types and operations to represent SQL expresions - i.e. the columns in a SQL query. * The Render folder is all about (pretty)printing queries into their final SQL form. * The Untyped.Monad module provides a simple monadic interface to constructing queries. 2. A SQL runner with some basic support for running queries on Postgres and Redshift. 3. A Spec orchestrator that allows for expression of chains of table/view creations, updates and re-creations with interdependencies that are automatically managed. * Entire SQL based computation pipelines can be expressed this way and have their periodic updates managed automatically by the framework. * Specs are necessarily stateful; we currently persist metadata in a local sqlite3 database, which can be migrated to a more serious database solution. 4. A command line interface that can take Specs and provide convenient flags for forcing certain table updates, skipping others, etc. ## Key features * Unused CTE column detection. * Transparent support multiple SQL-like backends (Postgres, BigQuery, Redshift) * Powerful template engine available in SQL queries * Seamless integration macro functions with SQL * Capabilities are extensible with type safest generic programming language. ## Let's Go [Go! Go! Go!](/getting-started) ",
    "url": "/about/",
    "relUrl": "/about/"
  },"1": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": "# Getting Started ## Installation **Napkin** app is available in 2 forms: [live installer](#live-installer) and [dockerized version](#docker-version). ### Live installer Live installer is a self extracting and self contained SHELL archive, which doesn't require docker nor nix environment. As for now live installer [repository](https://soostone-napkin-public.s3.us-east-1.amazonaws.com/index.html){:target=\"_blank\" rel=\"noopener\"} has versions for Mac OS Big Sur and Linux based distros. Find a page corresponding to your environment, copy installation snipped and executed it locally. Let's say you run Mac, the latest build for MacOS Big Sur: ``` shell curl -s https://soostone-napkin-public.s3.us-east-1.amazonaws.com/x86_64-MacOS-20.5.0/last-build/napkin-live-installer.sh \\ | bash -s -- ``` The bundle is very fat and it contains all dependencies. If you need access to `ghci` - supply file pattern for derivations with apps you are interested in: ``` shell curl -s https://soostone-napkin-public.s3.us-east-1.amazonaws.com/x86_64-MacOS-20.5.0/last-build/napkin-live-installer.sh \\ | bash -s -- -e '*-ghc-*' ``` ghc derivation contains **ghci-8.10.4**. Pathes to napkin and all ghc apps are goin to be imported through `$PATH` variable. Don't forget to start new shell session to update `$PATH` variable or you can benefit from `exec $SHELL` trick. #### Uninstallation Napkin Live installer provides an uninstaller too. Type `uninstall-` and use tab to auto-complete script doing napkin uninstallation. ``` shell $ uninstall- $ uninstall-b82gj7f0igpw23sapafxifsrr0f52771-napkin-0.3.8.sh ``` ### Docker version Live installer is great, because it is very lightweight, but it is not available on [Windows](https://en.wikipedia.org/wiki/Microsoft_Windows) yet. There are tutorials on the Internet for setting up [Nix](https://nixos.wiki/wiki/Nix) with [WSL](https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux) on Windows. ## Hello world Napkin has lots of interesting features and the toolset is constantlly growing. We have a bold roadmap for years! Let's consider a killer feature, which has a pretty simple user interface. Detection unused [CTE](https://en.wikipedia.org/wiki/Hierarchical_and_recursive_queries_in_SQL#Common_table_expression) columns. Some columns are introduced for debugging and development purpose, but as time goes engineer can stop using them and forget, meanwhile such column could contribute significantl to costs of running queries. For comprehensive list of use cases follow [here](/). ",
    "url": "/getting-started/",
    "relUrl": "/getting-started/"
  },"2": {
    "doc": "Haddock",
    "title": "Haddock",
    "content": "# Haddock ## Docs for versions * [Version 0.3.8]({{site.haddoc_url}}/app-version/index.html) ## Docs for branches * [last build]({{site.haddoc_url}}/last-build/index.html) * [master]({{site.haddoc_url}}/branch/master/index.html) * [Full list of branches with haddoc]({{site.haddoc_url}}/branch/index.html) ",
    "url": "/haddock/",
    "relUrl": "/haddock/"
  },"3": {
    "doc": "Tutorial",
    "title": "Tutorial",
    "content": "# Tutorial ",
    "url": "/tutorial/",
    "relUrl": "/tutorial/"
  },"4": {
    "doc": "User Manual",
    "title": "User Manual",
    "content": "# User Manual ",
    "url": "/user-manual/",
    "relUrl": "/user-manual/"
  }
}
